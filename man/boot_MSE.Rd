% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/boot_MSE.R
\name{boot_MSE}
\alias{boot_MSE}
\alias{boot_MSE.mse_b}
\alias{boot_MSE.mse_3t}
\alias{boot_MSE.mse_spa}
\alias{boot_MSE.mse_bc}
\title{Bootstrap MSE}
\usage{
boot_MSE(...)

\method{boot_MSE}{mse_b}(obj_var, boot_samples, ...)

\method{boot_MSE}{mse_3t}(obj_var, boot_samples, cluster_means, var_u_est, var_e_est, ...)

\method{boot_MSE}{mse_spa}(obj_var, boot_samples, cluster_means, var_u_est, var_e_est, ...)

\method{boot_MSE}{mse_bc}(obj_var, boot_samples, ...)
}
\arguments{
\item{...}{Additional parameters}

\item{obj_var}{Variance object}

\item{boot_samples}{List of bootstrap samples}

\item{cluster_means}{Cluster-level covariates for fixed parameters}

\item{var_u_est}{Variance of random effects}

\item{var_e_est}{Variance of errors}
}
\value{
List with following parameters:
\item{mse_mixed}{Mean squared error}
\item{rmse_mixed}{Root mean squared error}
}
\description{
Generic function to obtain bootstrap MSE estimates
}
\section{Methods (by class)}{
\itemize{
\item \code{mse_b}: Function to compute bootstrap MSE estimates

\item \code{mse_3t}: Function to compute 3-term bootstrap MSE estimates

\item \code{mse_spa}: Function to compute semiparametric bootstrap estimates

\item \code{mse_bc}: Function to compute bias-corrected
bootstrap MSE estimate
}}

\examples{

set.seed(11992)
m = 25
n_j = 5
n = m * n_j
scaling_factor_e = 1
scaling_factor_u = sqrt(0.5)
x_ij = runif(n, 0, 1)
X = cbind(X0 = rep(1, n), X1 = x_ij)
t_X  = t(X)
id_cluster = rep(1:m, each = n_j)
beta = c(1, 1)

cluster_means <- as.matrix(aggregate(X,
list(id_cluster),
FUN = mean)[, -1])

#Formula to construct intervals
formula_y <-  y ~ -1 + X0 + X1 + (1| id_cluster)

data_sample <- generate_NERM(generate_u = list(type = "chisquared",
                                               scaling_factor = 1,
                                               dg = 6),
                             generate_e = list(type = "chisquared",
                                               scaling_factor = 1,
                                               dg = 6),
                             beta = beta,
                             X = X,
                             id_cluster = id_cluster,
                             start_seed = 1,
                             no_sim = 1,
                             cluster_means = cluster_means)


fitted_NERM <- fit_NERM(formula_y, data_sample,
                        id_cluster, cluster_means)

type_method = c("parametric")
class(type_method) <- type_method

# Bootstrap MSE

boot_samples <- bootstrap_NERM(type_method,
                               var_u_est = fitted_NERM$var_u,
                               var_e_est = fitted_NERM$var_e,
                               beta_est = fitted_NERM$beta_hat,
                               boot_seed = 2,
                               n_boot = 100, formula_y,
                               data_sample = data_sample,
                               id_cluster = id_cluster,
                               cluster_means = cluster_means,
                               type_var_estimator = "mse_b")

type_var_estimator = "mse_b"
class(type_var_estimator) <- "mse_b"

boot_mixed <- boot_MSE(type_var_estimator, boot_samples,
                       cluster_means, var_u_est, var_e_est)

# Bias-corrected bootstrap MSE

boot_samples <- bootstrap_NERM(type_method,
                               var_u_est = fitted_NERM$var_u,
                               var_e_est = fitted_NERM$var_e,
                               beta_est = fitted_NERM$beta_hat,
                               boot_seed = 2,
                               n_boot = 100, formula_y,
                               data_sample = data_sample,
                               id_cluster = id_cluster,
                               cluster_means = cluster_means,
                               type_var_estimator = "mse_bc")

type_var_estimator = "mse_bc"
class(type_var_estimator) <- "mse_bc"

boot_mixed <- boot_MSE(type_var_estimator, boot_samples,
                       cluster_means, var_u_est, var_e_est)

}
